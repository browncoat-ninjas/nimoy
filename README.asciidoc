= Nimoy

A testing and specification framework for Python 3, heavily inspired by the amazing http://spockframework.org/[Spock Framework].

image:https://badge.fury.io/py/nimoy-framework.svg["PyPI version", link="https://badge.fury.io/py/nimoy-framework"]
image:https://travis-ci.org/browncoat-ninjas/nimoy.svg?branch=master["Build Status", link="https://travis-ci.org/browncoat-ninjas/nimoy"]

== Why?

The http://spockframework.org/[Spock Framework] has set a new standard as to what testing frameworks should be like - beautiful, expressive, pragmatic and fun.

While `unittest`, https://github.com/pytest-dev/pytest[pytest] and https://github.com/nose-devs/nose2[nose2] are great, there's still room for improvement.

The aim of this project is to port Spock to Python while maintaining the original vision as much as possible.

== Features

* Based on `unittest`, so minimal dependencies are required and specifications are recognized by IDEs and report analyzers.
* Reduction of boilerplate code.
* Write detailed specifications with clear distinction.
* Auto discovery of specifications.
* Write data-driven specifications.
* Pretty mock behavior assertion.
* See fancy detailed assertion failure reports.

== Learn More

* https://browncoat-ninjas.github.io/nimoy/[About]
* https://browncoat-ninjas.github.io/nimoy/user-guide/[User Guide]
* https://browncoat-ninjas.github.io/nimoy/contributing/[Contributing]


=== Stimulus and Response Specification

A specification with a `setup`, `when` and `then` block.
`when` blocks describe a certain action and `then` blocks assert the results of that action.

.stimulus_and_response_spec.py
[source,python]
----
from nimoy.specification import Specification

class MySpec(Specification):

    def my_feature_method(self):
        with setup:
            a = 1

        with when:
            a = a + 1

        with then:
            a == 2
----

=== Expecting Exceptions

Use the `thrown` method to make sure that an expected exception has been thrown.

.expected_exceptions_spec.py
[source,python]
----
from nimoy.specification import Specification

class MySpec(Specification):

    def my_feature_method(self):
        with when:
            raise Exception('Whaaaaat')
        with then:
            err = thrown(Exception)
            str(err[1]) == 'Whaaaaat'
----

=== Data-driven Specification

Using the powerful `where` block, we can parametrise our specification and execute it multiple times with different sets of data.

.date_driven_spec.py
[source,python]
----
from nimoy.specification import Specification

class MySpec(Specification):

    def my_feature_method(self):
        with given:
            a = value_of_a
            b = value_of_b

        with expect:
            (a * b) == expected_value

        with where:
            value_of_a | value_of_b | expected_value
            1          | 10         | 10
            2          | 20         | 40
----

=== Pretty Mock Response Staging

When using `unittest` Mocks you can stage the return values using binary operators.

Use the right shift to always return the same value (`return_value`):

.pretty_mock_response_staging_return_value.py
[source,python]
----
from unittest import mock
from nimoy.specification import Specification

class MySpec(Specification):

    def my_feature_method(self):
        with setup:
            the_mock = mock.Mock()

        with when:
            the_mock.some_method() >> 5

        with then:
            the_mock.some_method() == 5
            the_mock.some_method() == 5
            the_mock.some_method() == 5
----

Or use the left shift operator to return a different value on every invocation (`side_effect`):

.pretty_mock_response_staging_side_effect.py
[source,python]
----
from unittest import mock
from nimoy.specification import Specification

class MySpec(Specification):

    def my_feature_method(self):
        with setup:
            the_mock = mock.Mock()

        with when:
            the_mock.some_method() << [5, 6, 7]

        with then:
            the_mock.some_method() == 5
            the_mock.some_method() == 6
            the_mock.some_method() == 7
----

=== Pretty Mock Assertions

When using `unittest` Mocks you can write pretty assertions in the `then` block.
Mock assertion expressions are written like a mathematical expression with the format of `[NUMBER_OF_INVOCATIONS] * [INVOCATION_TARGET]`.

`[NUMBER_OF_INVOCATIONS]` may be a wildcard when filled in with `\_`.
Invocation target arguments may also be wildcarded by placing `_`. For example, `class.method(_, 3)`.

.pretty_mock_assertions.py
[source,python]
----
from unittest import mock
from nimoy.specification import Specification

class MySpec(Specification):

    def my_feature_method(self):
        with setup:
            the_mock = mock.Mock()

        with when:
            the_mock.some_method('abcd', True)

        with then:
            1 * the_mock.some_method('abcd', True)
----

=== Syntactic Sugar

Different routine operations have shorthands to make your specifications cleaner and more readable

.syntatic_sugar.py
[source,python]
----
from unittest import mock
from nimoy.specification import Specification

class MySpec(Specification):

    def regex_assertion(self):
        with expect:
            'The quick brown fox' @ '.+brown.+' # This is valid regex matching!
----

== License

Apache License 2.0

== In memory of Leonard Nimoy 1931-2015
