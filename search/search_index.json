{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nimoy A testing and specification framework for Python 3, heavily inspired by the amazing Spock Framework . Why Nimoy? The Spock Framework has set a new standard as to what testing frameworks should be like - beautiful, expressive, pragmatic and fun. While unittest , pytest and nose2 are great, there's still room for improvement. The aim of this project is to port Spock to Python while maintaining the original vision as much as possible. Main Features Based on unittest , so minimal dependencies are required and specifications are recognized by IDEs and report analyzers Reduction of boilerplate code Write detailed specifications with clear distinction Auto discovery of specifications Write data-driven specifications Pretty mock behavior assertion See fancy detailed assertion failure reports","title":"Home"},{"location":"#nimoy","text":"A testing and specification framework for Python 3, heavily inspired by the amazing Spock Framework .","title":"Nimoy"},{"location":"#why-nimoy","text":"The Spock Framework has set a new standard as to what testing frameworks should be like - beautiful, expressive, pragmatic and fun. While unittest , pytest and nose2 are great, there's still room for improvement. The aim of this project is to port Spock to Python while maintaining the original vision as much as possible.","title":"Why Nimoy?"},{"location":"#main-features","text":"Based on unittest , so minimal dependencies are required and specifications are recognized by IDEs and report analyzers Reduction of boilerplate code Write detailed specifications with clear distinction Auto discovery of specifications Write data-driven specifications Pretty mock behavior assertion See fancy detailed assertion failure reports","title":"Main Features"},{"location":"contributing/","text":"Contributing Nimoy is an open source project and welcomes contributions of any kind - bug reports, feature requests, documentation improvements and code. Bug Reports If you think you've found a bug in Nimoy, first make sure that you are using the latest version. We also suggest searching for a similar report in the project's open GitHub issues. Bug reports in form of actual test cases are best as they provide the quickest path to reproduction. Contributing Code To contribute new features or bug fixes: Fork and clone the repository Use pipenv to download the dependencies using: pipenv install -d Apply your changes, including test cases that prove them Run pylint to make sure that the quality of the code hasn't deteriorated: pipenv run lint Run all tests and make sure none have been broken: pipenv run test & pipenv run test-with-power Submit the changes using a pull request. Make sure you provide as much detail as possible","title":"Contributing"},{"location":"contributing/#contributing","text":"Nimoy is an open source project and welcomes contributions of any kind - bug reports, feature requests, documentation improvements and code.","title":"Contributing"},{"location":"contributing/#bug-reports","text":"If you think you've found a bug in Nimoy, first make sure that you are using the latest version. We also suggest searching for a similar report in the project's open GitHub issues. Bug reports in form of actual test cases are best as they provide the quickest path to reproduction.","title":"Bug Reports"},{"location":"contributing/#contributing-code","text":"To contribute new features or bug fixes: Fork and clone the repository Use pipenv to download the dependencies using: pipenv install -d Apply your changes, including test cases that prove them Run pylint to make sure that the quality of the code hasn't deteriorated: pipenv run lint Run all tests and make sure none have been broken: pipenv run test & pipenv run test-with-power Submit the changes using a pull request. Make sure you provide as much detail as possible","title":"Contributing Code"},{"location":"examples/","text":"Examples Pretty Failure Messages Power Assertions (Beta): Power assertions is in beta! This feature can be turned on using the --power-assertions switch. Taking inspiration from Groovy , power assertions take the failed assertion statement and break it down so that you can better understand the problem. from nimoy.specification import Specification class MySpec(Specification): def use_power_assertions(self): with setup: class SomeClass: def __init__(self): self.val = {'d': 'e'} def __str__(self): return str(self.val) sc = SomeClass() with expect: sc.val['d'] == 'f' Running this spec using nimoy --power-assertions true produces: ====================================================================== FAIL: use_power_assertions (builtins.MySpec) ---------------------------------------------------------------------- Traceback (most recent call last): [redacted] AssertionError: Assertion failed: sc.val['d'] == f | | | | e False {'d': 'e'} String Assertions from nimoy.specification import Specification class MySpec(Specification): def string_assertion(self): with given: a = \"There's a huge difference\" with expect: a == \"There's a small difference\" Produces ====================================================================== FAIL: string_assertion (builtins.MySpec) ---------------------------------------------------------------------- Traceback (most recent call last): [redacted] AssertionError: Expected: \"There's a small difference\" but: was \"There's a huge difference\" Hint: - There's a huge difference ? ^^^^ + There's a small difference ? ^^^^^ Mock Assertions from nimoy.specification import Specification from unittest import mock class MySpec(Specification): def mock_assertion(self): with setup: the_mock = mock.Mock() with when: the_mock.some_method() with then: 2 * the_mock.some_method() Produces ====================================================================== FAIL: mock_assertion (builtins.MySpec) ---------------------------------------------------------------------- Traceback (most recent call last): [redacted] AssertionError: some_method was to be invoked 2 times but was invoked 1 Stimulus and Response Specification A specification with a setup , when and then block. when blocks describe a certain action and then blocks assert the results of that action. from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with setup: a = 1 with when: a = a + 1 with then: a == 2 Expecting Exceptions Use the thrown method to make sure that an expected exception has been thrown. from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with when: raise Exception('Whaaaaat') with then: err = thrown(Exception) str(err[1]) == 'Whaaaaat' Data-driven Specification Using the powerful where block, we can parametrise our specification and execute it multiple times with different sets of data. Data as a Matrix We can set the parameters in the form of a matrix. from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with given: a = value_of_a b = value_of_b with expect: (a * b) == expected_value with where: value_of_a | value_of_b | expected_value 1 | 10 | 10 2 | 20 | 40 Data as a List We can also set the parameters in the form of lists. from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with given: a = value_of_a b = value_of_b with expect: (a * b) == expected_value with where: value_of_a = [1, 2] value_of_b = [10, 20] expected_value = [10, 40] Pretty Mock Response Staging When using unittest mocks you can stage the return values using binary operators. Use the right shift to always return the same value ( return_value ): from unittest import mock from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with setup: the_mock = mock.Mock() with when: the_mock.some_method() >> 5 with then: the_mock.some_method() == 5 the_mock.some_method() == 5 the_mock.some_method() == 5 Or use the left shift operator to return a different value on every invocation ( side_effect ): from unittest import mock from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with setup: the_mock = mock.Mock() with when: the_mock.some_method() << [5, 6, 7] with then: the_mock.some_method() == 5 the_mock.some_method() == 6 the_mock.some_method() == 7 Pretty Mock Assertions When using unittest Mocks you can write pretty assertions in the then block. Mock assertion expressions are written like a mathematical expression with the format of [NUMBER_OF_INVOCATIONS] * [INVOCATION_TARGET] . [NUMBER_OF_INVOCATIONS] may be a wildcard when filled in with \\_ . Invocation target arguments may also be wildcarded by placing _ . For example, class.method(_, 3) . from unittest import mock from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with setup: the_mock = mock.Mock() with when: the_mock.some_method('abcd', True) with then: 1 * the_mock.some_method('abcd', True) RegEx Matching Use the @ shorthand for pretty regex matching. import re from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with expect: 'The quick brown fox' @ '.+brown.+' # This is valid regex matching! 'The quick\\nbrown fox' @ re.compile('.+brown.+', re.MULTILINE) # You can also provide your own pattern Skipping Features You can use unittest's standard decorator to skip features. import unittest from nimoy.specification import Specification class MySpec(Specification): @unittest.skip def my_feature_method(self): with given: a = 'The quick brown fox' with expect: a == 'The quick frown box'","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#pretty-failure-messages","text":"","title":"Pretty Failure Messages"},{"location":"examples/#power-assertions-beta","text":"Power assertions is in beta! This feature can be turned on using the --power-assertions switch. Taking inspiration from Groovy , power assertions take the failed assertion statement and break it down so that you can better understand the problem. from nimoy.specification import Specification class MySpec(Specification): def use_power_assertions(self): with setup: class SomeClass: def __init__(self): self.val = {'d': 'e'} def __str__(self): return str(self.val) sc = SomeClass() with expect: sc.val['d'] == 'f' Running this spec using nimoy --power-assertions true produces: ====================================================================== FAIL: use_power_assertions (builtins.MySpec) ---------------------------------------------------------------------- Traceback (most recent call last): [redacted] AssertionError: Assertion failed: sc.val['d'] == f | | | | e False {'d': 'e'}","title":"Power Assertions (Beta):"},{"location":"examples/#string-assertions","text":"from nimoy.specification import Specification class MySpec(Specification): def string_assertion(self): with given: a = \"There's a huge difference\" with expect: a == \"There's a small difference\" Produces ====================================================================== FAIL: string_assertion (builtins.MySpec) ---------------------------------------------------------------------- Traceback (most recent call last): [redacted] AssertionError: Expected: \"There's a small difference\" but: was \"There's a huge difference\" Hint: - There's a huge difference ? ^^^^ + There's a small difference ? ^^^^^","title":"String Assertions"},{"location":"examples/#mock-assertions","text":"from nimoy.specification import Specification from unittest import mock class MySpec(Specification): def mock_assertion(self): with setup: the_mock = mock.Mock() with when: the_mock.some_method() with then: 2 * the_mock.some_method() Produces ====================================================================== FAIL: mock_assertion (builtins.MySpec) ---------------------------------------------------------------------- Traceback (most recent call last): [redacted] AssertionError: some_method was to be invoked 2 times but was invoked 1","title":"Mock Assertions"},{"location":"examples/#stimulus-and-response-specification","text":"A specification with a setup , when and then block. when blocks describe a certain action and then blocks assert the results of that action. from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with setup: a = 1 with when: a = a + 1 with then: a == 2","title":"Stimulus and Response Specification"},{"location":"examples/#expecting-exceptions","text":"Use the thrown method to make sure that an expected exception has been thrown. from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with when: raise Exception('Whaaaaat') with then: err = thrown(Exception) str(err[1]) == 'Whaaaaat'","title":"Expecting Exceptions"},{"location":"examples/#data-driven-specification","text":"Using the powerful where block, we can parametrise our specification and execute it multiple times with different sets of data.","title":"Data-driven Specification"},{"location":"examples/#data-as-a-matrix","text":"We can set the parameters in the form of a matrix. from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with given: a = value_of_a b = value_of_b with expect: (a * b) == expected_value with where: value_of_a | value_of_b | expected_value 1 | 10 | 10 2 | 20 | 40","title":"Data as a Matrix"},{"location":"examples/#data-as-a-list","text":"We can also set the parameters in the form of lists. from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with given: a = value_of_a b = value_of_b with expect: (a * b) == expected_value with where: value_of_a = [1, 2] value_of_b = [10, 20] expected_value = [10, 40]","title":"Data as a List"},{"location":"examples/#pretty-mock-response-staging","text":"When using unittest mocks you can stage the return values using binary operators. Use the right shift to always return the same value ( return_value ): from unittest import mock from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with setup: the_mock = mock.Mock() with when: the_mock.some_method() >> 5 with then: the_mock.some_method() == 5 the_mock.some_method() == 5 the_mock.some_method() == 5 Or use the left shift operator to return a different value on every invocation ( side_effect ): from unittest import mock from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with setup: the_mock = mock.Mock() with when: the_mock.some_method() << [5, 6, 7] with then: the_mock.some_method() == 5 the_mock.some_method() == 6 the_mock.some_method() == 7","title":"Pretty Mock Response Staging"},{"location":"examples/#pretty-mock-assertions","text":"When using unittest Mocks you can write pretty assertions in the then block. Mock assertion expressions are written like a mathematical expression with the format of [NUMBER_OF_INVOCATIONS] * [INVOCATION_TARGET] . [NUMBER_OF_INVOCATIONS] may be a wildcard when filled in with \\_ . Invocation target arguments may also be wildcarded by placing _ . For example, class.method(_, 3) . from unittest import mock from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with setup: the_mock = mock.Mock() with when: the_mock.some_method('abcd', True) with then: 1 * the_mock.some_method('abcd', True)","title":"Pretty Mock Assertions"},{"location":"examples/#regex-matching","text":"Use the @ shorthand for pretty regex matching. import re from nimoy.specification import Specification class MySpec(Specification): def my_feature_method(self): with expect: 'The quick brown fox' @ '.+brown.+' # This is valid regex matching! 'The quick\\nbrown fox' @ re.compile('.+brown.+', re.MULTILINE) # You can also provide your own pattern","title":"RegEx Matching"},{"location":"examples/#skipping-features","text":"You can use unittest's standard decorator to skip features. import unittest from nimoy.specification import Specification class MySpec(Specification): @unittest.skip def my_feature_method(self): with given: a = 'The quick brown fox' with expect: a == 'The quick frown box'","title":"Skipping Features"},{"location":"user-guide/","text":"User Guide Installation pip install nimoy-framework Quickstart Let's create your first spec! Project Structure Within your project directory create a specs directory: . +-- mymodule/ +-- __init__.py +-- my_module.py +-- specs/ <-- Added a new folder for the specifications +-- __init__.py +-- README.md +-- index.html Nimoy Modules Ideally every one of your Python modules may be represented by a Nimoy module, so you can mimic your application's directory structure within the specs folder. Within the specs folder create a new module named my_module_spec.py . Note : Nimoy will only pick up on modules ending with _spec.py . . +-- mymodule/ +-- __init__.py +-- my_module.py +-- specs/ +-- __init__.py +-- my_module_spec.py <-- Added a new folder for the specifications +-- README.md +-- index.html Your First Specification To be considered as a specification, your class must end with the name Spec and must extend the Specification class. Any public method within the specification class will be treated as a feature method. # my_module_spec.py from nimoy.specification import Specification # The class name ends with Spec and extends Specification class MyFirstSpec(Specification): # The feature method is public def my_feature_method(self): with given: a = 'The quick brown fox' with expect: a == 'The quick frown box' # This is not a feature method def _helper_method(self): pass Running Your Specification Simply execute nimoy within your project directory. Nimoy will auto-discover all your specs! $ nimoy my_feature_method (builtins.MyFirstSpec) ... FAIL ====================================================================== FAIL: my_feature_method (builtins.MySpec) ---------------------------------------------------------------------- AssertionError: Expected: 'The quick frown box' but: was 'The quick brown fox' Hint: - The quick brown fox ? ^ ^ + The quick frown box ? ^ ^ ---------------------------------------------------------------------- Ran 1 test in 0.002s FAILED (failures=1) Running Nimoy Run All By default, Nimoy will run all the specifications in the current directory and in any child directory: $ nimoy Run Some You can tell Nimoy to run the specifications in certain directories: $ nimoy subdir-1 subdir-2 Run Just Nimoy can run specific modules: $ nimoy subdir-1/my_spec.py subdir-2/my_other_spec.py Or certain specifications: $ nimoy subdir-1/my_spec.py::ThisSpec subdir-2/my_other_spec.py::TheOtherSpec And even specific features: $ nimoy subdir-1/my_spec.py::ThisSpec::this_feature subdir-2/my_other_spec.py::the_other_feature","title":"User Guide"},{"location":"user-guide/#user-guide","text":"","title":"User Guide"},{"location":"user-guide/#installation","text":"pip install nimoy-framework","title":"Installation"},{"location":"user-guide/#quickstart","text":"Let's create your first spec!","title":"Quickstart"},{"location":"user-guide/#project-structure","text":"Within your project directory create a specs directory: . +-- mymodule/ +-- __init__.py +-- my_module.py +-- specs/ <-- Added a new folder for the specifications +-- __init__.py +-- README.md +-- index.html","title":"Project Structure"},{"location":"user-guide/#nimoy-modules","text":"Ideally every one of your Python modules may be represented by a Nimoy module, so you can mimic your application's directory structure within the specs folder. Within the specs folder create a new module named my_module_spec.py . Note : Nimoy will only pick up on modules ending with _spec.py . . +-- mymodule/ +-- __init__.py +-- my_module.py +-- specs/ +-- __init__.py +-- my_module_spec.py <-- Added a new folder for the specifications +-- README.md +-- index.html","title":"Nimoy Modules"},{"location":"user-guide/#your-first-specification","text":"To be considered as a specification, your class must end with the name Spec and must extend the Specification class. Any public method within the specification class will be treated as a feature method. # my_module_spec.py from nimoy.specification import Specification # The class name ends with Spec and extends Specification class MyFirstSpec(Specification): # The feature method is public def my_feature_method(self): with given: a = 'The quick brown fox' with expect: a == 'The quick frown box' # This is not a feature method def _helper_method(self): pass","title":"Your First Specification"},{"location":"user-guide/#running-your-specification","text":"Simply execute nimoy within your project directory. Nimoy will auto-discover all your specs! $ nimoy my_feature_method (builtins.MyFirstSpec) ... FAIL ====================================================================== FAIL: my_feature_method (builtins.MySpec) ---------------------------------------------------------------------- AssertionError: Expected: 'The quick frown box' but: was 'The quick brown fox' Hint: - The quick brown fox ? ^ ^ + The quick frown box ? ^ ^ ---------------------------------------------------------------------- Ran 1 test in 0.002s FAILED (failures=1)","title":"Running Your Specification"},{"location":"user-guide/#running-nimoy","text":"","title":"Running Nimoy"},{"location":"user-guide/#run-all","text":"By default, Nimoy will run all the specifications in the current directory and in any child directory: $ nimoy","title":"Run All"},{"location":"user-guide/#run-some","text":"You can tell Nimoy to run the specifications in certain directories: $ nimoy subdir-1 subdir-2","title":"Run Some"},{"location":"user-guide/#run-just","text":"Nimoy can run specific modules: $ nimoy subdir-1/my_spec.py subdir-2/my_other_spec.py Or certain specifications: $ nimoy subdir-1/my_spec.py::ThisSpec subdir-2/my_other_spec.py::TheOtherSpec And even specific features: $ nimoy subdir-1/my_spec.py::ThisSpec::this_feature subdir-2/my_other_spec.py::the_other_feature","title":"Run Just"}]}